"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readBlockMapDataFromAppImage = exports.SIGNATURE_HEADER_SIZE = exports.BLOCK_MAP_FILE_NAME = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

let readBlockMapDataFromAppImage = exports.readBlockMapDataFromAppImage = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (file) {
        const fd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(file, "r");
        try {
            const fileSize = (yield (0, (_fsExtraP || _load_fsExtraP()).fstat)(fd)).size;
            const sizeBuffer = Buffer.allocUnsafe(4);
            yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, sizeBuffer, 0, sizeBuffer.length, fileSize - sizeBuffer.length);
            const dataBuffer = Buffer.allocUnsafe(sizeBuffer.readUInt32BE(0));
            yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, dataBuffer, 0, dataBuffer.length, fileSize - sizeBuffer.length - dataBuffer.length);
            yield (0, (_fsExtraP || _load_fsExtraP()).close)(fd);
            const inflateRaw = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify(require("zlib").inflateRaw);
            return (yield inflateRaw(dataBuffer)).toString();
        } catch (e) {
            yield (0, (_fsExtraP || _load_fsExtraP()).close)(fd);
            throw e;
        }
    });

    return function readBlockMapDataFromAppImage(_x) {
        return _ref.apply(this, arguments);
    };
})();
//# sourceMappingURL=blockMapApi.js.map


var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const BLOCK_MAP_FILE_NAME = exports.BLOCK_MAP_FILE_NAME = "_blockMap.yml";
const SIGNATURE_HEADER_SIZE = exports.SIGNATURE_HEADER_SIZE = 12 /* signature + 2 bytes version + 4 bytes CRC */ + 20;