"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RemoteBuilder = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

var _zipBin;

function _load_zipBin() {
    return _zipBin = require("7zip-bin");
}

var _http;

function _load_http() {
    return _http = require("http2");
}

var _child_process;

function _load_child_process() {
    return _child_process = require("child_process");
}

var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _path = _interopRequireWildcard(require("path"));

var _fs;

function _load_fs() {
    return _fs = require("fs");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { HTTP2_HEADER_PATH, HTTP2_METHOD_POST, HTTP2_HEADER_METHOD, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_STATUS, HTTP_STATUS_OK, HTTP_STATUS_BAD_REQUEST } = (_http || _load_http()).constants;
class RemoteBuilder {
    build(platform, targets, unpackedDirectory, packager, outDir) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const result = yield _this.sendRequest({
                "x-targets": targets,
                "x-platform": platform
            }, unpackedDirectory, packager, outDir);
            if (result != null && result.error != null) {
                throw new Error(`Remote builder error (if you think that it is not your application misconfiguration issue, please file issue to https://github.com/electron-userland/electron-builder/issues):\n\n${result.error}`);
            }
        })();
    }
    sendRequest(customHeaders, unpackedDirectory, packager, outDir) {
        const buildServiceEndpoint = process.env.ELECTRON_BUILD_SERVICE_ENDPOINT;
        if (buildServiceEndpoint == null) {
            throw new Error("Please set env ELECTRON_BUILD_SERVICE_ENDPOINT to URL of Electron Build Service URL");
        }
        const client = (0, (_http || _load_http()).connect)(buildServiceEndpoint);
        return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {
            client.on("socketError", reject);
            client.on("error", reject);
            let handled = false;
            let files = null;
            let finishedStreamCount = 0;
            client.on("stream", (stream, headers) => {
                const file = headers[HTTP2_HEADER_PATH];
                if ((_builderUtil || _load_builderUtil()).debug.enabled) {
                    (0, (_builderUtil || _load_builderUtil()).debug)(`Remote builder stream: ${file}`);
                }
                const localFile = _path.join(outDir, file);
                const fileStream = (0, (_fs || _load_fs()).createWriteStream)(localFile);
                fileStream.on("error", reject);
                stream.on("error", reject);
                stream.on("end", () => {
                    finishedStreamCount++;
                    if ((_builderUtil || _load_builderUtil()).debug.enabled) {
                        (0, (_builderUtil || _load_builderUtil()).debug)(`Remote artifact saved to: ${localFile}`);
                    }
                    if (files != null && finishedStreamCount >= files.length) {
                        resolve();
                    }
                });
                stream.pipe(fileStream);
            });
            client.on("close", () => {
                if (!handled) {
                    reject(new Error("Closed unexpectedly"));
                }
            });
            client.on("timeout", () => {
                if (!handled) {
                    reject(new Error("Timeout"));
                }
            });
            const stream = client.request(Object.assign({ [HTTP2_HEADER_PATH]: "/v1/build", [HTTP2_HEADER_METHOD]: HTTP2_METHOD_POST, [HTTP2_HEADER_CONTENT_TYPE]: "application/octet-stream" }, customHeaders));
            stream.on("error", reject);
            uploadUnpackedAppArchive(stream, unpackedDirectory, _path.join(packager.appDir, "package.json"), resolve, reject);
            stream.on("response", headers => {
                handled = true;
                const status = headers[HTTP2_HEADER_STATUS];
                if (status !== HTTP_STATUS_OK && status !== HTTP_STATUS_BAD_REQUEST) {
                    reject(`Error: ${status}`);
                    return;
                }
                let data = "";
                stream.setEncoding("utf8");
                stream.on("data", chunk => {
                    data += chunk;
                });
                stream.on("end", () => {
                    const result = data.length === 0 ? {} : JSON.parse(data);
                    if ((_builderUtil || _load_builderUtil()).debug.enabled) {
                        (0, (_builderUtil || _load_builderUtil()).debug)(`Remote builder result: ${JSON.stringify(result, null, 2)}`);
                    }
                    if (status === HTTP_STATUS_BAD_REQUEST) {
                        reject(new Error(JSON.stringify(result, null, 2)));
                        return;
                    }
                    files = result.files;
                    if (files == null) {
                        if (result.error == null) {
                            reject("Incorrect result, list of files is expected");
                        } else {
                            resolve(result);
                        }
                        return;
                    }
                    // pushed streams can be already handled
                    if (finishedStreamCount >= files.length) {
                        resolve();
                    }
                });
            });
        }).catch(error => {
            client.destroy();
            throw error;
        });
    }
}
exports.RemoteBuilder = RemoteBuilder; // compress and upload in the same time, directly to remote without intermediate local file

function uploadUnpackedAppArchive(stream, unpackedDirectory, appPackageJson, resolve, reject) {
    if ((_builderUtil || _load_builderUtil()).debug.enabled) {
        (0, (_builderUtil || _load_builderUtil()).debug)(`Use ${appPackageJson} as project package.json for remote build`);
    }
    // noinspection SpellCheckingInspection
    const tarProcess = (0, (_child_process || _load_child_process()).spawn)((_zipBin || _load_zipBin()).path7za, ["a", "dummy", "-ttar", "-so", unpackedDirectory, appPackageJson], {
        stdio: ["pipe", "pipe", process.stderr]
    });
    tarProcess.stdout.on("error", reject);
    const zstdProcess = (0, (_child_process || _load_child_process()).spawn)("zstd", ["-" + (process.env.RB_ZSTD_COMPRESSION || "22"), "--long"], {
        stdio: ["pipe", "pipe", process.stderr]
    });
    zstdProcess.on("error", reject);
    tarProcess.stdout.pipe(zstdProcess.stdin);
    zstdProcess.stdout.pipe(stream);
}
//# sourceMappingURL=RemoteBuilder.js.map