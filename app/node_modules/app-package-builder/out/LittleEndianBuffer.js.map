{"version":3,"file":"LittleEndianBuffer.js","sourceRoot":"","sources":["../src/LittleEndianBuffer.ts"],"names":[],"mappings":";;;;;;;;;AAAA,AAAO,AAAE,AAAO,AAAE,AAAM,AAAc,AAEtC,AAAM;;;;;AACJ,gBAA6B,AAAc,QAAU,QAAQ,AAAC;AAAjC,aAAM,SAAN,AAAM,AAAQ;AAAU,aAAK,QAAL,AAAK,AAAI,AAC9D;AAAC;AAED,AAEG;;;AACH,AAAK;AACH,AAAM,eAAC,AAAI,KAAC,AAAM,OAAC,AAAK,MAAC,AAAI,KAAC,AAAK,AAAC,AACtC;AAAC;AAED,AAAQ;AACN,AAAM,eAAC,AAAI,KAAC,AAAM,OAAC,AAAQ,SAAC,AAAI,KAAC,AAAK,AAAE,AAAC,AAC3C;AAAC;AAED,AAAgB;AACd,AAAM,eAAC,AAAI,KAAC,AAAM,OAAC,AAAS,UAAC,AAAI,KAAC,AAAK,AAAE,AAAC,AAC5C;AAAC;AAED,AAAQ;AACN,cAAM,AAAK,QAAG,AAAI,AAAO,kDAAC,AAAI,KAAC,AAAM,QAAE,AAAI,KAAC,AAAK,AAAC,OAAC,AAAQ,AAAE;AAC7D,AAAI,aAAC,AAAK,SAAI,AAAC;AACf,AAAM,eAAC,AAAK,AACd;AAAC;AAED,AAAO;AACL,cAAM,AAAK,QAAG,AAAI,KAAC,AAAM,OAAC,AAAW,YAAC,AAAI,KAAC,AAAK,AAAC;AACjD,AAAI,aAAC,AAAK,SAAI,AAAC;AACf,AAAM,eAAC,AAAK,AACd;AAAC;AAED,AAAe;AACb,cAAM,AAAK,QAAG,AAAI,KAAC,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAK,AAAC;AAClD,AAAI,aAAC,AAAK,SAAI,AAAC;AACf,AAAM,eAAC,AAAK,AACd;AAAC;AAED,AAAG,QAAC,AAAW;AACb,AAAI,aAAC,AAAM,OAAC,AAAI,KAAC,AAAG,KAAE,AAAC,GAAE,AAAI,KAAC,AAAK,AAAC;AACpC,AAAI,aAAC,AAAK,SAAI,AAAG,IAAC,AAAM,AAC1B;AAAC;AAED,AAAI,SAAC,AAAa;AAChB,AAAI,aAAC,AAAK,SAAI,AAAK,AACrB;AAAC;AAED,AAAS;AACP,AAAM,eAAC,AAAI,KAAC,AAAM,OAAC,AAAM,SAAG,AAAI,KAAC,AAAK,AACxC;AAAC,AACF","sourcesContent":["import { Int64LE } from \"int64-buffer\"\n\nexport class LittleEndianBuffer {\n  constructor(private readonly buffer: Buffer, private index = 0) {\n  }\n\n  /**\n   * Creates a new byte buffer whose content is a shared subsequence of this buffer's content.\n   */\n  slice() {\n    return this.buffer.slice(this.index)\n  }\n\n  readByte() {\n    return this.buffer.readInt8(this.index++)\n  }\n\n  readUnsignedByte() {\n    return this.buffer.readUInt8(this.index++)\n  }\n\n  readLong() {\n    const value = new Int64LE(this.buffer, this.index).toNumber()\n    this.index += 8\n    return value\n  }\n\n  readInt(): number {\n    const value = this.buffer.readInt32LE(this.index)\n    this.index += 4\n    return value\n  }\n\n  readUnsignedInt(): number {\n    const value = this.buffer.readUInt32LE(this.index)\n    this.index += 4\n    return value\n  }\n\n  get(dst: Buffer) {\n    this.buffer.copy(dst, 0, this.index)\n    this.index += dst.length\n  }\n\n  skip(count: number) {\n    this.index += count\n  }\n\n  remaining() {\n    return this.buffer.length - this.index\n  }\n}"]}
