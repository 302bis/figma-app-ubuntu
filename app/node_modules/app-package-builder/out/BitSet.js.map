{"version":3,"file":"BitSet.js","sourceRoot":"","sources":["../src/BitSet.ts"],"names":[],"mappings":";;;;;AAAA,MAAM,AAAgB,mBAAG,AAAC;AAC1B,MAAM,AAAqB,wBAAG,AAAC,AAE/B,AAAM;;AAMJ,gBAAY,AAAa;AACvB,AAAI,aAAC,AAAK,QAAG,IAAI,AAAK,MAAC,AAAS,UAAC,AAAK,QAAG,AAAC,AAAC,KAAG,AAAC,AAAC,AAClD;AAAC;AAED,AAAK,UAAC,AAAgB;AACpB,cAAM,AAAK,QAAG,AAAS,UAAC,AAAQ,AAAC;AACjC,AAAM,eAAC,AAAI,KAAC,AAAK,MAAC,AAAK,AAAC,SAAG,AAAI,KAAC,AAAK,MAAC,AAAK,AAAC,SAAG,CAAC,AAAI,KAAC,AAAQ,AAAC,AAChE;AAAC;AAED,AAAG,QAAC,AAAgB;AAClB,AAAE,AAAC,YAAC,AAAQ,WAAG,AAAC,AAAC,GAAC,AAAC;AACjB,kBAAM,IAAI,AAAK,AAAC,uBAAiB,AAAQ,QAAE,AAAC,AAC9C;AAAC;AAED,cAAM,AAAK,QAAG,AAAS,UAAC,AAAQ,AAAC;AACjC,AAAM,eAAC,AAAI,KAAC,AAAK,MAAC,AAAK,AAAC,SAAG,AAAI,KAAC,AAAK,MAAC,AAAK,AAAC,SAAG,AAAI,KAAC,AAAQ,AAAC,AAC/D;AAAC;AAED,AAAG,QAAC,AAAgB;AAClB,cAAM,AAAS,YAAG,AAAS,UAAC,AAAQ,AAAC;AACrC,AAAM,eAAC,AAAS,YAAG,AAAI,KAAC,AAAK,MAAC,AAAM,UAAI,CAAC,AAAI,KAAC,AAAK,MAAC,AAAS,AAAC,aAAG,AAAI,KAAC,AAAQ,AAAC,AAAC,eAAK,AAAC,AACxF;AAAC;AAED,AAAW;AACT,YAAI,AAAI;AACR,YAAI,AAAG,MAAG,AAAC;AACX,cAAM,AAAU,aAAG,AAAI,KAAC,AAAK;AAC7B,cAAM,AAAQ,WAAG,AAAI,KAAC,AAAK,MAAC,AAAM;AAClC,AAAG,AAAC,aAAC,AAAI,OAAG,AAAC,GAAE,AAAI,OAAG,AAAQ,UAAE,AAAI,QAAI,AAAC,GAAE,AAAC;AAC1C,kBAAM,AAAQ,WAAG,AAAU,WAAC,AAAI,AAAC,SAAI,AAAC;AACtC,AAAuE;AACvE,AAAG,AAAC,iBAAC,IAAI,AAAI,OAAG,AAAQ,UAAE,AAAI,SAAK,AAAC,GAAE,AAAI,AAAI,QAAC,AAAI,OAAG,AAAC,AAAC,GAAE,AAAC;AACzD,AAAG,uBAAI,AAAC,AACV;AAAC,AACH;AAAC;AACD,AAAM,eAAC,AAAG,AACZ;AAAC,AACF;;;AAED,mBAAmB,AAAgB;AACjC,AAAM,WAAC,AAAQ,YAAI,AAAqB,AAC1C;AAAC;AAED,AAEG;;;AACH,mBAAmB,AAAgB;AACjC,AAAM,WAAC,AAAQ,YAAI,AAAgB,AACrC;AAAC;AAED,AAEG;;;AACH,cAAc,AAAgB;AAC5B,AAAM,WAAC,AAAC,AAAI,MAAC,AAAQ,WAAG,AAAE,AAAC,AAC7B;AAAC","sourcesContent":["const SHIFTS_OF_A_WORD = 5\nconst ADDRESS_BITS_PER_WORD = 6\n\nexport class BitSet {\n  //_words property is an array of 32bits integers, javascript doesn't really have integers separated from Number type\n  //it's less performant because of that, number (by default float) would be internally converted to 32bits integer then accepts the bit operations\n  //checked Buffer type, but needs to handle expansion/downsize by application, compromised to use number array for now.\n  private readonly words: Array<number>\n\n  constructor(nbits: number) {\n    this.words = new Array(wordIndex(nbits - 1) + 1)\n  }\n\n  clear(bitIndex: number) {\n    const which = whichWord(bitIndex)\n    return this.words[which] = this.words[which] & ~mask(bitIndex)\n  }\n\n  set(bitIndex: number) {\n    if (bitIndex < 0) {\n      throw new Error(`bitIndex < 0: ${bitIndex}`)\n    }\n\n    const which = whichWord(bitIndex)\n    return this.words[which] = this.words[which] | mask(bitIndex)\n  }\n\n  get(bitIndex: number): boolean {\n    const wordIndex = whichWord(bitIndex)\n    return wordIndex < this.words.length && (this.words[wordIndex] & mask(bitIndex)) !== 0\n  }\n\n  cardinality() {\n    let next\n    let sum = 0\n    const arrOfWords = this.words\n    const maxWords = this.words.length\n    for (next = 0; next < maxWords; next += 1) {\n      const nextWord = arrOfWords[next] || 0\n      //this loops only the number of set bits, not 32 constant all the time!\n      for (let bits = nextWord; bits !== 0; bits &= (bits - 1)) {\n        sum += 1\n      }\n    }\n    return sum\n  }\n}\n\nfunction wordIndex(bitIndex: number) {\n  return bitIndex >> ADDRESS_BITS_PER_WORD\n}\n\n/**\n * @return {Number} the index at the words array\n */\nfunction whichWord(bitIndex: number) {\n  return bitIndex >> SHIFTS_OF_A_WORD\n}\n\n/**\n * @return {Number} a bit mask of 32 bits, 1 bit set at pos % 32, the rest being 0\n */\nfunction mask(bitIndex: number) {\n  return 1 << (bitIndex & 31)\n}\n"]}
